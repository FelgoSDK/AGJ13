# checksum 0x5b42 version 0x70013
# This file was generated by the Qt Quick Application wizard of Qt Creator.
# The code below adds the QmlApplicationViewer to the project and handles the
# activation of QML debugging.
# It is recommended not to modify this file, since newer versions of Qt Creator
# may offer an updated version of it.
# -> this is a modified version of the original qmlapplicationviewer.pri generated from QtCreator for V-Play!
# the difference is that is supports absolute paths as DEPLOYMENTFOLDERS source and correct deployment when the pro file is located in a different folder than the qmlapplicationviewer
# the file name was changed from qmlapplicationviewer.pri to "vplayqmlapplicationviewer.pri", so QtCreator does not ask if it wants to be updated! that is also important for QtCreator 2.6, which has no support for Symbian any more, but we want to keep symbian support, so the QmlApplicationViewer implementation is a merge from QtCreator2.6 and previous versions

QT += declarative

SOURCES += $$PWD/qmlapplicationviewer.cpp
HEADERS += $$PWD/qmlapplicationviewer.h
INCLUDEPATH += $$PWD

# Include JS debugger library if QMLJSDEBUGGER_PATH is set
!isEmpty(QMLJSDEBUGGER_PATH) {
    include($$QMLJSDEBUGGER_PATH/qmljsdebugger-lib.pri)
} else {
    DEFINES -= QMLJSDEBUGGER
}

contains(CONFIG,qdeclarative-boostable):contains(MEEGO_EDITION,harmattan) {
    DEFINES += HARMATTAN_BOOSTER
}
# This file was generated by an application wizard of Qt Creator.
# The code below handles deployment to Symbian and Maemo, aswell as copying
# of the application data to shadow build directories on desktop.
# It is recommended not to modify this file, since newer versions of Qt Creator
# may offer an updated version of it.

defineTest(qtcAddDeployment) {
for(deploymentfolder, DEPLOYMENTFOLDERS) {
    item = item$${deploymentfolder}
    itemsources = $${item}.sources
    $$itemsources = $$eval($${deploymentfolder}.source)
    itempath = $${item}.path
    $$itempath= $$eval($${deploymentfolder}.target)
    export($$itemsources)
    export($$itempath)
    DEPLOYMENT += $$item
}

# this is different than the normal qmlapplicationviewer!
# it is necessary, because for the demos the qmlapplicationviewer gets included from the shared directory, but the qml deploymentfolders should be added relative to the demo directory
# this gets set in each demo game and is needed, because the projectinclude.pri file is in a different directory than the demos (in the directory "shared")
isEmpty(DEPLOYMENTFOLDERS_SOURCE) {
    MAINPROFILEPWD = $$PWD
} else {
    MAINPROFILEPWD = $$DEPLOYMENTFOLDERS_SOURCE
}
message(MAINPROFILEPWD: $$MAINPROFILEPWD)

symbian {
    isEmpty(ICON):exists($${TARGET}.svg):ICON = $${TARGET}.svg
    isEmpty(TARGET.EPOCHEAPSIZE):TARGET.EPOCHEAPSIZE = 0x20000 0x2000000
} else:win32 {
    copyCommand =
    for(deploymentfolder, DEPLOYMENTFOLDERS) {

        source = $$eval($${deploymentfolder}.source)
        message(original source of deploymentfolder: $$source)

        # this regular expression looks for a path with the second character being a colon, e.g. C:/ or D:\
        # i.e. when the regexp returns a string, this means the path was set by defining an absolute path - in that case NO MAINPROFILEPWD should be appended below
        isAbsolutePathWindows = $$find(source, .:)
        message(isAbsolutePathWindows: $$isAbsolutePathWindows)

        isEmpty(isAbsolutePathWindows) {
            source = $$MAINPROFILEPWD/$$eval($${deploymentfolder}.source)
            message(appending the pro file to the beginning of the file name; as the deploymentfolder source was a relative path; new source: $$source)
        }

        source = $$replace(source, /, \\)
        sourcePathSegments = $$split(source, \\)
        target = $$OUT_PWD/$$eval($${deploymentfolder}.target)/$$last(sourcePathSegments)
        target = $$replace(target, /, \\)
        target ~= s,\\\\\\.?\\\\,\\,
        !isEqual(source,$$target) {
            !isEmpty(copyCommand):copyCommand += &&
            isEqual(QMAKE_DIR_SEP, \\) {
                copyCommand += $(COPY_DIR) \"$$source\" \"$$target\"
            } else {
                source = $$replace(source, \\\\, /)
                target = $$OUT_PWD/$$eval($${deploymentfolder}.target)
                target = $$replace(target, \\\\, /)
                copyCommand += test -d \"$$target\" || mkdir -p \"$$target\" && cp -r \"$$source\" \"$$target\"
            }
        }
    }
    !isEmpty(copyCommand) {
        copyCommand = @echo Copying application data... && $$copyCommand
        copydeploymentfolders.commands = $$copyCommand
        first.depends = $(first) copydeploymentfolders
        export(first.depends)
        export(copydeploymentfolders.commands)
        QMAKE_EXTRA_TARGETS += first copydeploymentfolders
    }
} else:unix {
    maemo5 {
        desktopfile.files = $${TARGET}.desktop
        desktopfile.path = /usr/share/applications/hildon
        icon.files = $${TARGET}64.png
        icon.path = /usr/share/icons/hicolor/64x64/apps
    } else:!isEmpty(MEEGO_VERSION_MAJOR) {
        desktopfile.files = $${TARGET}_harmattan.desktop
        desktopfile.path = /usr/share/applications
        icon.files = $${TARGET}80.png
        icon.path = /usr/share/icons/hicolor/80x80/apps
    } else { # Assumed to be a Desktop Unix
        copyCommand =
        for(deploymentfolder, DEPLOYMENTFOLDERS) {            

            source = $$eval($${deploymentfolder}.source)

            # NOTE: DEPLOYMENTFOLDER may also be set to an absolute path - in that case, do not append $$MAINPROFILEPWD!
            # this regexp looks for a path that starts with a slash, e.g. /usr/ or /opt/ - if it is not empty, this means it is a relative path and the path to the MAINPROFILE should be appended
            isAbsolutePathUnix = $$find(source, ^/)
            isEmpty(isAbsolutePathUnix) {
                source = $$MAINPROFILEPWD/$$eval($${deploymentfolder}.source)
            }

            source = $$replace(source, \\\\, /)
            macx {
                target = $$OUT_PWD/$${TARGET}.app/Contents/Resources/$$eval($${deploymentfolder}.target)
            } else {
                target = $$OUT_PWD/$$eval($${deploymentfolder}.target)
            }
            target = $$replace(target, \\\\, /)
            sourcePathSegments = $$split(source, /)
            targetFullPath = $$target/$$last(sourcePathSegments)
            targetFullPath ~= s,/\\.?/,/,
            !isEqual(source,$$targetFullPath) {
                !isEmpty(copyCommand):copyCommand += &&
                copyCommand += $(MKDIR) \"$$target\"
                copyCommand += && $(COPY_DIR) \"$$source\" \"$$target\"
            }
        }
        !isEmpty(copyCommand) {
            copyCommand = @echo Copying application data... && $$copyCommand
            copydeploymentfolders.commands = $$copyCommand
            first.depends = $(first) copydeploymentfolders
            export(first.depends)
            export(copydeploymentfolders.commands)
            QMAKE_EXTRA_TARGETS += first copydeploymentfolders
        }
    }
    installPrefix = /opt/$${TARGET}
    for(deploymentfolder, DEPLOYMENTFOLDERS) {
        item = item$${deploymentfolder}
        itemfiles = $${item}.files
        $$itemfiles = $$eval($${deploymentfolder}.source)
        itempath = $${item}.path
        $$itempath = $${installPrefix}/$$eval($${deploymentfolder}.target)
        export($$itemfiles)
        export($$itempath)
        INSTALLS += $$item
    }

    !isEmpty(desktopfile.path) {
        export(icon.files)
        export(icon.path)
        export(desktopfile.files)
        export(desktopfile.path)
        INSTALLS += icon desktopfile
    }

    target.path = $${installPrefix}/bin
    export(target.path)
    INSTALLS += target
}

export (ICON)
export (INSTALLS)
export (DEPLOYMENT)
export (TARGET.EPOCHEAPSIZE)
export (TARGET.CAPABILITY)
export (LIBS)
export (QMAKE_EXTRA_TARGETS)
}

